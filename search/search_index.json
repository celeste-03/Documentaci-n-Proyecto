{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MODELO SENCILLO DE UN CAPACITOR Y SU SOLUCI\u00d3N NUM\u00c9RICA (ELECTROST\u00c1TICA)","text":""},{"location":"#coordinadores-marlon-brenes-y-federico-munoz","title":"Coordinadores: Marlon Brenes y Federico Mu\u00f1oz","text":""},{"location":"#estudiantes","title":"Estudiantes","text":"<ul> <li>Carlos Echandi Jara (B92687)</li> <li>Natalia Iannarella Arguedas (A83166)</li> <li>\u00c1ngel Fabricio Aguirre Berm\u00fadez (C10152)</li> <li>Mar\u00eda Celeste Ure\u00f1a Sand\u00ed (B98009)</li> </ul> <p>Bienvenidos al proyecto de simulaci\u00f3n de ecuaciones diferenciales aplicadas a un modelo de forma ideal un capacitor electr\u00f3nico.</p> <p>Se resuelve la ecuaci\u00f3n de Laplace en dos dimensiones para el potencial electrost\u00e1tico</p> <p>\u03c6 = \u03c6(x, y)</p> <p></p> <p></p>"},{"location":"#descripcion","title":"Descripci\u00f3n","text":"<p>Este proyecto incluye:</p> <ul> <li>M\u00e9todos num\u00e9ricos para resolver ecuaciones diferenciales parciales.</li> <li>Implementaciones en Python y C++.</li> <li>Simulaciones paralelas con OpenMP.</li> <li>Visualizaci\u00f3n de resultados y an\u00e1lisis num\u00e9rico.</li> </ul>"},{"location":"codigo_cpp/Gauss_Seidel/","title":"Soluci\u00f3n de la Ecuaci\u00f3n de Laplace en C++","text":"<p>Este programa en C++ resuelve la ecuaci\u00f3n de Laplace en una grilla 2D utilizando el m\u00e9todo de relajaci\u00f3n iterativa.</p>"},{"location":"codigo_cpp/Gauss_Seidel/#codigo-fuente","title":"C\u00f3digo Fuente","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt; // Para std::abs\n#include &lt;algorithm&gt; // Para std::max\n\ndouble calcular_delta(const std::vector&lt;double&gt; &amp;phi, const std::vector&lt;double&gt; &amp;phi_copy) {\n    double delta = 0.0;\n    for (size_t i = 0; i &lt; phi.size(); ++i) {\n        delta = std::max(delta, std::abs(phi[i] - phi_copy[i]));\n    }\n    return delta;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 7) {\n        std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" --N [Tama\u00f1o lineal de la grilla cuadrada (NxN)] --t [Tolerancia] --L [Tama\u00f1o lineal del capacitor cuadrado (LxL)]\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    std::cout &lt;&lt; \"Bienvenido.\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Se esta calculando la solucion de la ecuacion de Laplace bajo los parametros definidos...\" &lt;&lt; std::endl;\n\n    int N = atoi(argv[2]);  // Tama\u00f1o de la grilla (NxN)\n    double tolerance = atof(argv[4]);  // Tolerancia\n    int L = atoi(argv[6]);  // Tama\u00f1o lineal del capacitor fisico\n    int grilla_size = N + 1;  // Tama\u00f1o total de la grilla (incluye frontera)\n\n    std::vector&lt;double&gt; phi(grilla_size * grilla_size, 0.0);\n\n    int start_y = (N/L) * 2.0;  // Coordenada inicial (y = 2cm)\n    int end_y = (N/L) * 8.0;    // Coordenada final (y= 8cm)\n    int plate_x1 = (N / L) * 2.0; // L\u00ednea vertical izquierda (x = 2cm)\n    int plate_x2 = (N / L) * 8.0; // L\u00ednea vertical derecha (x = 8cm)\n\n    for (int i = start_y; i &lt; end_y; ++i) {\n        phi[i * grilla_size + plate_x1] = 1.0;  // +1V en la placa izquierda\n        phi[i * grilla_size + plate_x2] = -1.0; // -1V en la placa derecha\n    }\n\n    std::vector&lt;double&gt; phi_copy = phi;\n\n    double delta = 1.0;\n    int its = 0;\n\n    while (delta &gt; tolerance) {\n        its++;\n\n        for (int i = 1; i &lt; N; ++i) {\n            for (int j = 1; j &lt; N; ++j) {\n                phi[i * grilla_size + j] = (1.0 / 4.0) *\n                    (phi[(i + 1) * grilla_size + j] +\n                     phi[(i - 1) * grilla_size + j] +\n                     phi[i * grilla_size + (j + 1)] +\n                     phi[i * grilla_size + (j - 1)]);\n            }\n        }\n\n        for (int i = start_y; i &lt; end_y; ++i) {\n            phi[i * grilla_size + plate_x1] = 1.0;\n            phi[i * grilla_size + plate_x2] = -1.0;\n        }\n\n        delta = calcular_delta(phi, phi_copy);\n\n        phi_copy = phi;\n    }\n\n    std::cout &lt;&lt; \"Se llego a la tolerancia tras \" &lt;&lt; its &lt;&lt; \" iteraciones.\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Gr\u00e1fico </p>"},{"location":"codigo_cpp/Gauss_Seidel_Dist/","title":"Soluci\u00f3n de la Ecuaci\u00f3n de Laplace en C++","text":"<p>Este programa en C++ resuelve la ecuaci\u00f3n de Laplace en una grilla 2D utilizando el m\u00e9todo de relajaci\u00f3n iterativa.</p> <p>AAA</p>"},{"location":"codigo_cpp/Gauss_Seidel_Dist/#codigo-fuente","title":"C\u00f3digo Fuente","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt; // Para std::abs\n#include &lt;algorithm&gt; // Para std::max\n\ndouble calcular_delta(const std::vector&lt;double&gt; &amp;phi, const std::vector&lt;double&gt; &amp;phi_copy) {\n    double delta = 0.0;\n    for (size_t i = 0; i &lt; phi.size(); ++i) {\n        delta = std::max(delta, std::abs(phi[i] - phi_copy[i]));\n    }\n    return delta;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 7) {\n        std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" --N [Tama\u00f1o lineal de la grilla cuadrada (NxN)] --t [Tolerancia] --L [Tama\u00f1o lineal del capacitor cuadrado (LxL)]\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    std::cout &lt;&lt; \"Bienvenido.\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Se esta calculando la solucion de la ecuacion de Laplace bajo los parametros definidos...\" &lt;&lt; std::endl;\n\n    int N = atoi(argv[2]);  // Tama\u00f1o de la grilla (NxN)\n    double tolerance = atof(argv[4]);  // Tolerancia\n    int L = atoi(argv[6]);  // Tama\u00f1o lineal del capacitor fisico\n    int grilla_size = N + 1;  // Tama\u00f1o total de la grilla (incluye frontera)\n\n    std::vector&lt;double&gt; phi(grilla_size * grilla_size, 0.0);\n\n    int start_y = (N/L) * 2.0;  // Coordenada inicial (y = 2cm)\n    int end_y = (N/L) * 8.0;    // Coordenada final (y= 8cm)\n    int plate_x1 = (N / L) * 2.0; // L\u00ednea vertical izquierda (x = 2cm)\n    int plate_x2 = (N / L) * 8.0; // L\u00ednea vertical derecha (x = 8cm)\n\n    for (int i = start_y; i &lt; end_y; ++i) {\n        phi[i * grilla_size + plate_x1] = 1.0;  // +1V en la placa izquierda\n        phi[i * grilla_size + plate_x2] = -1.0; // -1V en la placa derecha\n    }\n\n    std::vector&lt;double&gt; phi_copy = phi;\n\n    double delta = 1.0;\n    int its = 0;\n\n    while (delta &gt; tolerance) {\n        its++;\n\n        for (int i = 1; i &lt; N; ++i) {\n            for (int j = 1; j &lt; N; ++j) {\n                phi[i * grilla_size + j] = (1.0 / 4.0) *\n                    (phi[(i + 1) * grilla_size + j] +\n                     phi[(i - 1) * grilla_size + j] +\n                     phi[i * grilla_size + (j + 1)] +\n                     phi[i * grilla_size + (j - 1)]);\n            }\n        }\n\n        for (int i = start_y; i &lt; end_y; ++i) {\n            phi[i * grilla_size + plate_x1] = 1.0;\n            phi[i * grilla_size + plate_x2] = -1.0;\n        }\n\n        delta = calcular_delta(phi, phi_copy);\n\n        phi_copy = phi;\n    }\n\n    std::cout &lt;&lt; \"Se llego a la tolerancia tras \" &lt;&lt; its &lt;&lt; \" iteraciones.\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Gr\u00e1fico </p>"},{"location":"codigo_cpp/Gauss_Seidel_Memloc/","title":"Soluci\u00f3n Paralela de la Ecuaci\u00f3n de Laplace con OpenMP","text":"<p>Este programa resuelve la ecuaci\u00f3n de Laplace en una grilla 2D utilizando el m\u00e9todo de relajaci\u00f3n iterativa, optimizado con OpenMP para computaci\u00f3n paralela.</p>"},{"location":"codigo_cpp/Gauss_Seidel_Memloc/#codigo-fuente","title":"C\u00f3digo Fuente","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt; // Para std::abs\n#include &lt;algorithm&gt; // Para std::max\n#include &lt;omp.h&gt; // OpenMP\n#include &lt;sys/time.h&gt; // Para medir tiempo\n\ndouble seconds()\n{\n  struct timeval tmp;\n  double sec;\n  gettimeofday(&amp;tmp, (struct timezone *)0);\n  sec = tmp.tv_sec + ((double)tmp.tv_usec) / 1000000.0;\n\n  return sec;\n}\n\ndouble calcular_delta(const std::vector&lt;double&gt; &amp;phi, const std::vector&lt;double&gt; &amp;phi_copy) {\n    double delta = 0.0;\n    for (size_t i = 0; i &lt; phi.size(); ++i) {\n        delta = std::max(delta, std::abs(phi[i] - phi_copy[i]));\n    }\n    return delta;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 7) {\n        std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" --N [Tama\u00f1o lineal de la grilla cuadrada (NxN)] --t [Tolerancia] --L [Tama\u00f1o lineal del capacitor cuadrado (LxL)]\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    std::cout &lt;&lt; \"Bienvenido.\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Se est\u00e1 calculando la soluci\u00f3n de la ecuaci\u00f3n de Laplace bajo los par\u00e1metros definidos...\" &lt;&lt; std::endl;\n\n    int N = atoi(argv[2]);\n    double tolerance = atof(argv[4]);\n    int L = atoi(argv[6]);\n    int grilla_size = N + 1;\n\n    std::vector&lt;double&gt; phi(grilla_size * grilla_size, 0.0);\n\n    int start_y = (N / L) * 2.0;\n    int end_y = (N / L) * 8.0;\n    int plate_x1 = (N / L) * 2.0;\n    int plate_x2 = (N / L) * 8.0;\n\n    for (int i = start_y; i &lt; end_y; ++i) {\n        phi[i * grilla_size + plate_x1] = 1.0;\n        phi[i * grilla_size + plate_x2] = -1.0;\n    }\n\n    std::vector&lt;double&gt; phi_copy = phi;\n\n    double delta = 1.0;\n    int its = 0;\n    int num_procs;\n    double time_1 = seconds();\n\n    while (delta &gt; tolerance) {\n        its++;\n#pragma omp parallel\n        {\n            num_procs = omp_get_num_threads();\n#pragma omp for\n            for (int i = 1; i &lt; N; ++i) {\n                for (int j = 1; j &lt; N; ++j) {\n                    if ((i &gt;= start_y &amp;&amp; i &lt;= end_y) &amp;&amp; (j == plate_x1 || j == plate_x2)) {\n                        // No se modifica la placa\n                    } else {\n                        phi[i * grilla_size + j] = (1.0 / 4.0) *\n                            (phi[(i + 1) * grilla_size + j] +\n                             phi[(i - 1) * grilla_size + j] +\n                             phi[i * grilla_size + (j + 1)] +\n                             phi[i * grilla_size + (j - 1)]);\n                    }\n                }\n            }\n        }\n\n        delta = calcular_delta(phi, phi_copy);\n        phi_copy = phi;\n    }\n\n    double time_2 = seconds();\n    std::cout &lt;&lt; \"Se lleg\u00f3 a la tolerancia tras \" &lt;&lt; its &lt;&lt; \" iteraciones.\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"N\u00famero de hilos: \" &lt;&lt; num_procs &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Tiempo total: \" &lt;&lt; time_2 - time_1 &lt;&lt; \" segundos\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Gr\u00e1fico </p> <p>Escalabilidad </p>"},{"location":"notebooks/jacobi_modificado/","title":"M\u00e9todo de Relajaci\u00f3n de Jacobi Modificado","text":"<p>Este notebook implementa una mejora al m\u00e9todo de Jacobi, a\u00f1adiendo sobre-relajaci\u00f3n para acelerar la convergencia en sistemas lineales.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\ndef jacobi_relaxation_mod(N, tolerance, L, V1, V2, omega):\n    # Inicializar la matriz phi (potencial el\u00e9ctrico)\n    phi = np.zeros((N + 1, N + 1), dtype=float)\n\n    # Aplicar condiciones de frontera\n    phi[int((N / L) * 2):int((N / L) * 8), int((N / L) * 2)] = V1\n    phi[int((N / L) * 2):int((N / L) * 8), int((N / L) * 8)] = V2\n\n    delta = 1.0\n    iteration = 0\n\n    while delta &gt; tolerance:\n        phi_new = phi.copy()\n        iteration += 1\n        phi_new[1:N, 1:N] = (1.0 + omega) * 0.25 * (\n            phi[2:N + 1, 1:N] + phi[0:N - 1, 1:N] + \n            phi[1:N, 2:N + 1] + phi[1:N, 0:N - 1]\n        ) - omega * phi[1:N, 1:N]\n\n        phi_new[int((N / L) * 2):int((N / L) * 8), int((N / L) * 2)] = V1\n        phi_new[int((N / L) * 2):int((N / L) * 8), int((N / L) * 8)] = V2\n\n        delta = np.max(np.abs(phi - phi_new))\n        phi = phi_new\n\n    print(f\"El m\u00e9todo convergi\u00f3 en {iteration} iteraciones.\")\n    return phi, iteration\n\nphi, num_iterations = jacobi_relaxation_mod(100, 1e-3, 10, 1, -1, 1.5)\n\n\nEl m\u00e9todo convergi\u00f3 en 523 iteraciones.\n\n/tmp/ipykernel_5055/757925980.py:23: RuntimeWarning: overflow encountered in add\n  phi[2:N + 1, 1:N] + phi[0:N - 1, 1:N] +\n/tmp/ipykernel_5055/757925980.py:25: RuntimeWarning: overflow encountered in multiply\n  ) - omega * phi[1:N, 1:N]\n/tmp/ipykernel_5055/757925980.py:22: RuntimeWarning: overflow encountered in subtract\n  phi_new[1:N, 1:N] = (1.0 + omega) * 0.25 * (\n/tmp/ipykernel_5055/757925980.py:32: RuntimeWarning: overflow encountered in subtract\n  delta = np.max(np.abs(phi - phi_new))\n/tmp/ipykernel_5055/757925980.py:23: RuntimeWarning: invalid value encountered in add\n  phi[2:N + 1, 1:N] + phi[0:N - 1, 1:N] +\n\n# Graficar el resultado despu\u00e9s de la convergencia, en este caso diverge este m\u00e9todo.\n#plt.figure(figsize=(8, 6))\n#plt.imshow(phi, extent=[0, 10, 0, 10], origin='lower', cmap='viridis', interpolation='bilinear')\n#plt.colorbar(label='Potencial el\u00e9ctrico (phi)')\n#plt.title(f'Distribuci\u00f3n del Potencial El\u00e9ctrico - Iteraciones: {num_iterations}')\n#plt.xlabel('x')\n#plt.ylabel('y')\n#plt.show()\n\n</code></pre>"},{"location":"scripts/Gauss_Seidel/","title":"M\u00e9todo de Gauss-Seidel","text":"<p>Este script implementa el m\u00e9todo de Gauss-Seidel para resolver sistemas de ecuaciones en una grilla 2D. Este m\u00e9todo es \u00fatil para simular el comportamiento del potencial el\u00e9ctrico en sistemas discretizados.</p>"},{"location":"scripts/Gauss_Seidel/#codigo-en-python","title":"C\u00f3digo en Python","text":"<pre><code>#!/usr/bin/env python\n\nimport numpy as np\n\ndef gauss_seidel(N=100, tolerance=1e-5, L=10, V1=1, V2=-1):\n    # Iniciaci\u00f3n de phi\n    phi = np.zeros((N + 1, N + 1), dtype=float)\n\n    # Condiciones iniciales (placas)\n    phi[int((N/L)*2):int((N/L)*8), int((N/L)*2)] = V1\n    phi[int((N/L)*2):int((N/L)*8), int((N/L)*8)] = V2\n\n    # Copia para evaluar el error\n    phi_copy = phi.copy()\n\n    delta = 1.0\n    its = 0\n\n    while delta &gt; tolerance:\n        its += 1\n\n        # Iteraci\u00f3n de Gauss-Seidel\n        for i in range(1, N):\n            for j in range(1, N):\n                phi[i, j] = (phi[i+1, j] + phi[i-1, j] + phi[i, j+1] + phi[i, j-1]) / 4.0\n\n        # Restauro el potencial en las placas\n        phi[int((N / L) * 2):int((N / L) * 8), int((N / L) * 2)] = V1\n        phi[int((N / L) * 2):int((N / L) * 8), int((N / L) * 8)] = V2\n\n        # Evaluar la convergencia\n        delta = np.max(np.abs(phi - phi_copy))\n        phi_copy = phi.copy()\n\n    return phi, its\n\ngauss_vals, iterations = gauss_seidel()\nprint(iterations)\n</code></pre> <p>Gr\u00e1fico </p>"},{"location":"scripts/Relajacion_Jacobi/","title":"Relajaci\u00f3n Jacobi","text":"<p>Este script implementa el m\u00e9todo de relajaci\u00f3n Jacobi para resolver sistemas de ecuaciones en una grilla 2D. Es \u00fatil en aplicaciones como simulaciones de potencial el\u00e9ctrico.</p>"},{"location":"scripts/Relajacion_Jacobi/#codigo","title":"C\u00f3digo","text":"<pre><code>import numpy as np\ndef jacobi_relaxation(N=100, tolerance=1e-5, L=10, V1=1, V2=-1):\n    # Iniciaci\u00f3n de phi\n    phi = np.zeros((N + 1, N + 1), dtype=float)\n    # Condiciones iniciales (placas)\n    phi[int((N/L)*2):int((N/L)*8), int((N/L)*2)] = V1\n    phi[int((N/L)*2):int((N/L)*8), int((N/L)*8)] = V2\n\n    delta = 1.0\n    its = 0\n\n    while delta &gt; tolerance:\n        its += 1\n        phi_new = phi.copy()\n        phi_new[1:N, 1:N] = (1.0/4.0) * (\n            phi[2:N + 1, 1:N] +\n            phi[0:N - 1, 1:N] +\n            phi[1:N, 2:N + 1] +\n            phi[1:N, 0:N - 1]\n        )\n        # Restauro el potencial en las placas\n        phi_new[int((N / L) * 2):int((N / L) * 8), int((N / L) * 2)] = V1\n        phi_new[int((N / L) * 2):int((N / L) * 8), int((N / L) * 8)] = V2\n\n        delta = np.max(np.abs(phi - phi_new))\n        phi = phi_new\n\n    return phi, its\n\njacobi_vals, iterations = jacobi_relaxation()\nprint(iterations)\n\nEn el jupyter:\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\n\nplt.imshow(jacobi_vals)\nplt.gray()\nplt.show()\n</code></pre> <p>Gr\u00e1fico </p>"}]}